---
title: 'Assignment: Local MDS and ISOMAP'
author: "Kevin Michael Frick, Sonia Petrini, Patrick Lutz"
output: pdf_document
---

# Local MDS for ZERO digits

```{r setup, include=FALSE}
library(stops)
library(dplyr)
zip.train <- read.table("zip.train")
zeros <- filter(zip.train, V1==0)
zeros <- as.matrix(zeros[,-1])
# ploting 1 digit
plot.zip <- function(x,use.first=FALSE,...){ x<-as.numeric(x)
if (use.first){
x.mat <- matrix(x,16,16) }else{
x.mat <- matrix(x[-1],16,16) }
image(1:16,1:16,x.mat[,16:1], col=gray(seq(1,0,l=12)),...)
invisible(
if (!use.first){
title(x[1]) }else{
} )
  #col=gray(seq(1,0,l=2)))
}

```

a. Look for a 2-dimensional (q = 2) configuration of the data using parameters k = 5 and Ï„ = 0.05 in lmdsfunction. Do the scatterplot of the obtained 2-dimensional configuration.

```{r}
distXY <- dist(zeros)
n <- dim(zeros)[1]

k <- 5
tau <- .05
q<-2 # 2-dim config

conf0 <- cmdscale(distXY, k=q)$points

lmds.zeros.res <- lmds(as.matrix(distXY), init=conf0, ndim=q, k=k, tau=tau, itmax = 20)
conf.lmds.zeros.res <- lmds.zeros.res$conf
```
```{r}
plot(conf.lmds.zeros.res, as=1, 
     main=paste0("Local MDS, k=",k,", tau=",tau), 
     xlab = "x1", ylab = "x2")
```
b. In the previous scatterplot, select a few points (9 points, for instance) located in such a way that they cover the variability of all the points in the scatterplot. Then use the function plot.zip to plot the ZERO digits corresponding to the selected points. The images you are plotting should allows you to give an interpretation of the 2 coordinates obtained by Local MDS (observe how the shape of ZEROs changes when moving along each directions of the scatterplot).

We select arrays containing the points that lie closest to the axes and then select those that lie at the extremes of the perpendicular axis. We do the same with the points which lie near the lines $x_1 = x_2$ and $x_1 = -x_2$.

```{r}
# Along x1 = 0
lmds.x1.idx <- abs(conf.lmds.zeros.res[,1]) < 2
lmds.x1 <- conf.lmds.zeros.res[which(lmds.x1.idx),1]
names(lmds.x1) <- which(lmds.x1.idx)
lmds.x1 <- sort(lmds.x1)
# Along x2 = 0
lmds.x2.idx <- abs(conf.lmds.zeros.res[,2]) < 2
lmds.x2 <- conf.lmds.zeros.res[which(lmds.x2.idx),1]
names(lmds.x2) <- which(lmds.x2.idx)
lmds.x2 <- sort(lmds.x2)
# Along x1 = x2
lmds.diag1.idx <- abs(conf.lmds.zeros.res[,1] - conf.lmds.zeros.res[,2]) < 1
lmds.diag1.temp <- conf.lmds.zeros.res[which(lmds.diag1.idx),1]
names(lmds.diag1.temp) <- which(lmds.diag1.idx)
lmds.diag1.temp <- sort(lmds.diag1.temp)
# Along x1 = -x2
lmds.diag2.idx <- abs(conf.lmds.zeros.res[,1] + conf.lmds.zeros.res[,2]) < 1
lmds.diag2.temp <- conf.lmds.zeros.res[which(lmds.diag2.idx),1]
names(lmds.diag2.temp) <- which(lmds.diag2.idx)
lmds.diag2.temp <- sort(lmds.diag2.temp)


```


We now plot the corresponding digits.

```{r}
nx1.zx2 <- as.numeric(head(names(lmds.x2), 1))
px1.zx2 <- as.numeric(tail(names(lmds.x2), 1))
zx1.nx2 <- as.numeric(head(names(lmds.x1), 1))
zx1.px2 <- as.numeric(tail(names(lmds.x1), 1))
nx1.nx2 <- as.numeric(head(names(lmds.diag1.temp), 1))
px1.px2 <- as.numeric(tail(names(lmds.diag1.temp), 1))
nx1.px2 <- as.numeric(head(names(lmds.diag2.temp), 1))
px1.nx2 <- as.numeric(tail(names(lmds.diag2.temp), 1))
centroid <- as.numeric(names(lmds.x1[length(lmds.x1)/2]), 1)
pts <- c(nx1.zx2, px1.zx2, zx1.nx2, zx1.px2, nx1.nx2, px1.px2, nx1.px2, px1.nx2, centroid)
plot(conf.lmds.zeros.res[pts,])

plot.zip(zeros[nx1.zx2,], TRUE, main = "Very negative x1, almost zero x2")
plot.zip(zeros[px1.zx2,], TRUE, main = "Very positive x1, almost zero x2")
plot.zip(zeros[zx1.nx2,], TRUE, main = "Almost zero x1, very negative x2")
plot.zip(zeros[zx1.px2,], TRUE, main = "Almost zero x1, very positive x2")
plot.zip(zeros[nx1.nx2,], TRUE, main = " Very negative x1 and x2")
plot.zip(zeros[px1.px2,], TRUE, main = "Very positive x1 and x2")
plot.zip(zeros[nx1.px2,], TRUE, main = "Very negative x1, very positive x2")
plot.zip(zeros[px1.nx2,], TRUE, main = "Very positive x1, very negative x2")
plot.zip(zeros[centroid,], TRUE, main = "Close to the origin")
```

We therefore interpret $x_1$ as radius and $x_2$ as stroke width, since values with a very negative $x_1$ correspond to narrow zeros and values with a large $x_1$ correspond to wide zeros.
The same reasoning applies to stroke width and $x_2$.

In this sense, MDS is encoding a value proportional to the logarithm of the inverse of the stroke width in $x_2$ or radius in $x_1$s.

c.  (OPTIONAL) Relate the results from Local MDS with those obtained by the first 3 principal components. In particular, could you represent in any way the results obtained by Local MDS in the 3-dimensional scatterplot pf (PC1,PC2,PC3)?


# ISOMAP for ZERO digits

a, b, c. Repeat previous points a and b (and OPTIONALLY c) but using now ISOMAP. Use function `isomap` from package vegan and use parameter k = 5 (instead of using $\epsilon$).

```{r}
library(vegan)
conf.ismp.zeros.res <- isomap(distXY,k=5,ndim=2)$points
```
```{r}
plot(conf.ismp.zeros.res,main="Output of ISOMAP Algorithm", xlab="x1", ylab="x2")
# Along x1 = 0
ismp.x1.idx <- abs(conf.ismp.zeros.res[,1]) < 2
ismp.x1 <- conf.ismp.zeros.res[which(ismp.x1.idx),1]
names(ismp.x1) <- which(ismp.x1.idx)
ismp.x1 <- sort(ismp.x1)
# Along x2 = 0
ismp.x2.idx <- abs(conf.ismp.zeros.res[,2]) < 2
ismp.x2 <- conf.ismp.zeros.res[which(ismp.x2.idx),1]
names(ismp.x2) <- which(ismp.x2.idx)
ismp.x2 <- sort(ismp.x2)
# Along x1 = x2
ismp.diag1.idx <- abs(conf.ismp.zeros.res[,1] - conf.ismp.zeros.res[,2]) < 1
ismp.diag1.temp <- conf.ismp.zeros.res[which(ismp.diag1.idx),1]
names(ismp.diag1.temp) <- which(ismp.diag1.idx)
ismp.diag1.temp <- sort(ismp.diag1.temp)
# Along x1 = -x2
ismp.diag2.idx <- abs(conf.ismp.zeros.res[,1] + conf.ismp.zeros.res[,2]) < 1
ismp.diag2.temp <- conf.ismp.zeros.res[which(ismp.diag2.idx),1]
names(ismp.diag2.temp) <- which(ismp.diag2.idx)
ismp.diag2.temp <- sort(ismp.diag2.temp)
```

We select points for plotting, using the same criterion as above.

We now plot the corresponding digits.

```{r}
nx1.zx2 <- as.numeric(head(names(ismp.x2), 1))
px1.zx2 <- as.numeric(tail(names(ismp.x2), 1))
zx1.nx2 <- as.numeric(head(names(ismp.x1), 1))
zx1.px2 <- as.numeric(tail(names(ismp.x1), 1))
nx1.nx2 <- as.numeric(head(names(ismp.diag1.temp), 1))
px1.px2 <- as.numeric(tail(names(ismp.diag1.temp), 1))
nx1.px2 <- as.numeric(head(names(ismp.diag2.temp), 1))
px1.nx2 <- as.numeric(tail(names(ismp.diag2.temp), 1))
centroid <- as.numeric(names(ismp.x1[length(ismp.x1)/2]), 1)
pts <- c(nx1.zx2, px1.zx2, zx1.nx2, zx1.px2, nx1.nx2, px1.px2, nx1.px2, px1.nx2, centroid)
plot(conf.ismp.zeros.res[pts,])

plot.zip(zeros[nx1.zx2,], TRUE, main = "Very negative x1, almost zero x2")
plot.zip(zeros[px1.zx2,], TRUE, main = "Very positive x1, almost zero x2")
plot.zip(zeros[zx1.nx2,], TRUE, main = "Almost zero x1, very negative x2")
plot.zip(zeros[zx1.px2,], TRUE, main = "Almost zero x1, very positive x2")
plot.zip(zeros[nx1.nx2,], TRUE, main = " Very negative x1 and x2")
plot.zip(zeros[px1.px2,], TRUE, main = "Very positive x1 and x2")
plot.zip(zeros[nx1.px2,], TRUE, main = "Very negative x1, very positive x2")
plot.zip(zeros[px1.nx2,], TRUE, main = "Very positive x1, very negative x2")
plot.zip(zeros[centroid,], TRUE, main = "Close to the origin")
```

d. Compare your results using ISOMAP with those obtained using Local MDS.

This time, we see that very positive values of $x_1$ correspond to higher radius, while very negative values of $x_1$ correspond to a lower radius. 

We also see that very negative values of $x_2$ correspond to a thicker stroke width, while very positive values correspond to a narrower width. 

# Selecting the tuning parameters for ZERO digits

a. Use the local continuity meta criteria to select the tuning parameter k in ISOMAP for ZERO digits. Then describe graphically the low dimensional configuration corresponding to the optimal parameter.


```{r}
LCMC <- function(D1,D2,Kp){
  D1 <- as.matrix(D1)
  D2 <- as.matrix(D2)
  n <- dim(D1)[1]
  N.Kp.i <- numeric(n)
  for (i in 1:n){
    N1.i <- sort.int(D1[i,],index.return = TRUE)$ix[1:Kp]
    N2.i <- sort.int(D2[i,],index.return = TRUE)$ix[1:Kp]
    N.Kp.i[i] <- length(intersect(N1.i, N2.i))
  }
  N.Kp<-mean(N.Kp.i)
  M.Kp.adj <- N.Kp/Kp - Kp/(n-1)
  
  return(list(N.Kp.i=N.Kp.i, M.Kp.adj=M.Kp.adj))
}

q <- 2

Kp <- 10

v.k <- 3:10

LC <- numeric(length(v.k))
ISOMAP.eps <- vector("list",length(v.k))

for (i in 1:length(v.k)){
  print(v.k[i])
  ISOMAP.eps[[i]] <- isomap(distXY, ndim=q, 
                            k= v.k[i])
  D2.eps <- dist(ISOMAP.eps[[i]]$points[,1:q])
  LC[i] <- LCMC(distXY,D2.eps,Kp)$M.Kp.adj
  #print(c(i,j,LC[i,j]))
}


i.max <- which.max(LC)
k.max <- v.k[i.max]
ISOMAP.max <- ISOMAP.eps[[i.max]]

plot(v.k, LC, type="b", main=paste0("The k maximizing the LCMC is ",k.max))

```
We now plot the resulting ISOMAP.
```{r}
plot(ISOMAP.max)
```
b. (OPTIONAL) Use the local continuity meta criteria to select the tuning parameters k and $\tau$ in Local MDS for ZERO digits. Then describe graphically the low dimensional configuration corresponding to the optimal parameter.

```{r}
q <- 2
Kp <- 10

K <- c(5,10,15)
tau <- c(.1,.5,1)

LC <- matrix(0,nrow=length(K),ncol=length(tau))
lmds.k.tau <- array(vector("list",1),dim=dim(LC))

for (i in 1:length(K)){
  for (j in 1:length(tau)){
    lmds.k.tau[[i,j]] <- lmds(as.matrix(distXY), k=K[i], ndim=q, tau=tau[j], itmax=20)
    D2.k.tau <- dist(lmds.k.tau[[i,j]]$conf)
    LC[i,j] <- LCMC(distXY,D2.k.tau,Kp)$M.Kp.adj
    #print(c(i,j,LC[i,j]))
  }
}

ij.max <- arrayInd(which.max(LC),.dim=dim(LC))
k.max <- K[ij.max[1]] 
tau.max <- tau[ij.max[2]] 
LocalMDS.max <- lmds.k.tau[[ij.max[1],ij.max[2]]]
print(paste0("The values maximizing the LCMC are k = ",k.max,"; tau = ",tau.max))
```

We now plot the resulting LMDS.
```{r}
plot(LocalMDS.max$conf)
```

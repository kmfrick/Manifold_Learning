---
title: 'Assignment: PCA and principal curves'
author: "Kevin Frick, Patrick Lutz, and Sonia Petrini"
date: "11/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Assignment: PCA and principal curves

Reading the data:
```{r}
library(dplyr)
zip.train <- read.table("zip.train")
zeros <- filter(zip.train, V1==0)
zeros <- zeros
```

a. Do a hierarchical clustering of these data using the ward.D method, plot the resulting dendogram and cut it into k=4 clusters
```{r}
dendo <- hclust(dist(zeros), method="ward.D")
plot(dendo)
dendo.4 <- cutree(dendo,4)
```

b. Plot the average digit at each cluster.
```{r}
plot.zip <- function(x,use.first=FALSE, main=NULL){
  x<-as.numeric(x)
  if (use.first){
    x.mat <- matrix(x,16,16)
  }else{
    x.mat <- matrix(x[-1],16,16)
  }
  image(1:16,1:16,x.mat[,16:1],
        col=gray(seq(1,0,l=12)))
  if (!is.null(main)) title(main)
  else if (!use.first) title(x[1])
  
  #col=gray(seq(1,0,l=2)))
}
for (i in 1:4) {
  plot.zip(colMeans(zeros[which(dendo.4==i),]), main = paste("Cluster", i))
}

```

c. Compute the principal components for this data set. Plot the scatterplot of the scores in the first two PCs, using a different color for points in different clusters.
```{r}
zip_pc <- princomp(zeros)
for (i in 1:5) {
  pts_in_cluster <- which(dendo.4==i)
  pc_scores <- zip_pc$scores[pts_in_cluster,1:2]
  xmin <- min(zip_pc$scores[,1])
  xmax <- max(zip_pc$scores[,1])
  ymin <- min(zip_pc$scores[,2])
  ymax <- max(zip_pc$scores[,2])

  if (i == 1) plot(pc_scores, col=i, xlim=c(xmin, xmax), ylim=c(ymin,ymax))
  else points(pc_scores, col=i)
}
```

d. For each one of the k clusters obtained above, do the following tasks: (A unique plot should be done, at which the k densities are represented simultaneously)
 - Consider the bivariate data set of the scores in PC1 and PC2 of the points in this cluster. 
 - Estimate non-parametrically the joint density of (PC1,PC2), conditional to this cluster. Use the default bandwith values. 
 - Represent the estimated bivariate density using the level curve that covers the 75% of the points in this cluster.
```{r}
library(sm)
options(error = function() traceback(10))

for (i in 1:5) {
  pts_in_cluster <- which(dendo.4==i)
  pc_scores <- zip_pc$scores[pts_in_cluster,1:2]
  xmin <- min(zip_pc$scores[,1])
  xmax <- max(zip_pc$scores[,1])
  ymin <- min(zip_pc$scores[,2])
  ymax <- max(zip_pc$scores[,2])

  if (i == 1) plot(pc_scores, col=i, xlim=c(xmin, xmax), ylim=c(ymin,ymax))
  else points(pc_scores, col=i)
  sm.density(pc_scores, col=i, display="slice", add=TRUE, props=c(75))
}

```

e. Over the previous plot, represent the principal curve obtained from the 256-dimensional set of zeros using the package princurve.
```{r}
library(princurve)
options(error = function() traceback(10))
xmin <- min(zip_pc$scores[,1])
xmax <- max(zip_pc$scores[,1])
ymin <- min(zip_pc$scores[,2])
ymax <- max(zip_pc$scores[,2])

options(error = function() traceback(10))
pc <- principal_curve(as.matrix(zeros), df=15)
points_to_pc <- predict(zip_pc, pc$s)
for (i in 1:5) {
  pts_in_cluster <- which(dendo.4==i)
  pc_scores <- zip_pc$scores[pts_in_cluster,1:2]
  if (i == 1) plot(pc_scores, col=i, xlim=c(xmin, xmax), ylim=c(ymin,ymax))
  else points(pc_scores, col=i)
}

lines(points_to_pc[pc$ord,1:2],col=6,lwd=2)
```

f. For each one of the k clusters obtained above, do the following tasks: (A unique scatter plot of the scores in PC1 and PC2 should be done, over which the k densities are represented simultaneously) 
 - Consider the univariate data set of the lambda scores over the principal curve of the points in this cluster. 
 - Estimate non-parametrically the density function of lambda, conditional to this cluster. Use the default bandwith value. 
 - Plot the estimated density function. 
```{r}
options(error = function() traceback(10))
xmin <- min(zip_pc$scores[,1])
xmax <- max(zip_pc$scores[,1])
ymin <- min(zip_pc$scores[,2])
ymax <- max(zip_pc$scores[,2])

options(error = function() traceback(10))

for (i in 1:5) {
  pts_in_cluster <- which(dendo.4==i)
  pc_scores <- zip_pc$scores[pts_in_cluster,1:2]
  if (i == 1) {
  sm.density(pc$lambda[pts_in_cluster], col=i, sm=75, xlab="Lambda")
} else {
    sm.density(pc$lambda[pts_in_cluster], col=i, add=TRUE, sm=75)

}

}


```